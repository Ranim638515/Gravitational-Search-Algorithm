# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z-g7wN8LTpSJ8UvhUhPGT88dqDONJDPM
"""

import numpy as np

# Fonction objectif : Sphere function
def sphere_function(x):
    return np.sum(x**2)

# Implémentation simple du GSA
class GSA:
    def __init__(self, num_agents=20, dim=5, max_iter=50, lb=-10, ub=10):
        self.num_agents = num_agents
        self.dim = dim
        self.max_iter = max_iter
        self.lb = lb
        self.ub = ub
        # Initialisation des agents
        self.positions = np.random.uniform(lb, ub, (num_agents, dim))
        self.velocities = np.zeros((num_agents, dim))
        self.best_solution = None
        self.best_fitness = float("inf")

    def fitness(self):
        return np.array([sphere_function(pos) for pos in self.positions])

    def run(self):
        for t in range(self.max_iter):
            fit = self.fitness()
            # Mise à jour du meilleur agent
            min_idx = np.argmin(fit)
            if fit[min_idx] < self.best_fitness:
                self.best_fitness = fit[min_idx]
                self.best_solution = self.positions[min_idx].copy()

            # Calcul des masses (fitness inversée)
            worst = np.max(fit)
            best = np.min(fit)
            masses = (fit - worst) / (best - worst + 1e-9)
            masses = masses / np.sum(masses)

            # Constante gravitationnelle décroissante
            G = 100 * np.exp(-20 * (t / self.max_iter))

            # Mise à jour des forces et accélérations
            forces = np.zeros((self.num_agents, self.dim))
            for i in range(self.num_agents):
                for j in range(self.num_agents):
                    if i != j:
                        dist = np.linalg.norm(self.positions[i] - self.positions[j]) + 1e-9
                        force = G * (masses[i] * masses[j]) / dist
                        direction = self.positions[j] - self.positions[i]
                        forces[i] += np.random.rand() * force * direction

            accelerations = forces / (masses[:, None] + 1e-9)

            # Mise à jour des vitesses et positions
            self.velocities = np.random.rand() * self.velocities + accelerations
            self.positions += self.velocities

            # Bornes
            self.positions = np.clip(self.positions, self.lb, self.ub)

            print(f"Iteration {t+1}, Best fitness: {self.best_fitness:.4f}")

        return self.best_solution, self.best_fitness


# Exemple d'utilisation
if __name__ == "__main__":
    gsa = GSA(num_agents=20, dim=5, max_iter=50)
    best_sol, best_fit = gsa.run()
    print("\nBest solution found:", best_sol)
    print("Best fitness value:", best_fit)

import numpy as np
import matplotlib.pyplot as plt

# === Benchmark functions ===
def sphere(x):
    return np.sum(x**2)

def rastrigin(x):
    return 10*len(x) + np.sum(x**2 - 10*np.cos(2*np.pi*x))

def rosenbrock(x):
    return np.sum(100*(x[1:] - x[:-1]**2)**2 + (x[:-1]-1)**2)

def ackley(x):
    return -20*np.exp(-0.2*np.sqrt(np.mean(x**2))) - np.exp(np.mean(np.cos(2*np.pi*x))) + 20 + np.e

# === Gravitational Search Algorithm ===
class GSA:
    def __init__(self, func, num_agents=30, dim=10, max_iter=100, lb=-5, ub=5):
        self.func = func
        self.num_agents = num_agents
        self.dim = dim
        self.max_iter = max_iter
        self.lb = lb
        self.ub = ub
        self.positions = np.random.uniform(lb, ub, (num_agents, dim))
        self.velocities = np.zeros((num_agents, dim))
        self.best_solution = None
        self.best_fitness = float("inf")
        self.history = []

    def fitness(self):
        return np.array([self.func(pos) for pos in self.positions])

    def run(self):
        for t in range(self.max_iter):
            fit = self.fitness()
            min_idx = np.argmin(fit)
            if fit[min_idx] < self.best_fitness:
                self.best_fitness = fit[min_idx]
                self.best_solution = self.positions[min_idx].copy()

            self.history.append(self.best_fitness)

            # Masses
            worst, best = np.max(fit), np.min(fit)
            masses = (fit - worst) / (best - worst + 1e-9)
            masses = masses / (np.sum(masses) + 1e-9)

            # Gravitation constant
            G = 100 * np.exp(-20 * (t / self.max_iter))

            # Forces
            forces = np.zeros((self.num_agents, self.dim))
            for i in range(self.num_agents):
                for j in range(self.num_agents):
                    if i != j:
                        dist = np.linalg.norm(self.positions[i] - self.positions[j]) + 1e-9
                        force = G * (masses[i] * masses[j]) / dist
                        direction = self.positions[j] - self.positions[i]
                        forces[i] += np.random.rand() * force * direction

            accelerations = forces / (masses[:, None] + 1e-9)

            # Update
            self.velocities = np.random.rand() * self.velocities + accelerations
            self.positions += self.velocities
            self.positions = np.clip(self.positions, self.lb, self.ub)

        return self.best_solution, self.best_fitness

# === Simple PSO for comparison ===
class PSO:
    def __init__(self, func, num_particles=30, dim=10, max_iter=100, lb=-5, ub=5):
        self.func = func
        self.num_particles = num_particles
        self.dim = dim
        self.max_iter = max_iter
        self.lb = lb
        self.ub = ub
        self.positions = np.random.uniform(lb, ub, (num_particles, dim))
        self.velocities = np.random.uniform(-1, 1, (num_particles, dim))
        self.pbest = self.positions.copy()
        self.pbest_val = np.array([self.func(p) for p in self.positions])
        self.gbest = self.positions[np.argmin(self.pbest_val)]
        self.gbest_val = np.min(self.pbest_val)
        self.history = []

    def run(self):
        for t in range(self.max_iter):
            for i in range(self.num_particles):
                fitness = self.func(self.positions[i])
                if fitness < self.pbest_val[i]:
                    self.pbest_val[i] = fitness
                    self.pbest[i] = self.positions[i].copy()
            if np.min(self.pbest_val) < self.gbest_val:
                self.gbest_val = np.min(self.pbest_val)
                self.gbest = self.pbest[np.argmin(self.pbest_val)].copy()

            self.history.append(self.gbest_val)

            # Update velocities and positions
            w, c1, c2 = 0.7, 1.5, 1.5
            r1, r2 = np.random.rand(), np.random.rand()
            self.velocities = (w*self.velocities +
                               c1*r1*(self.pbest - self.positions) +
                               c2*r2*(self.gbest - self.positions))
            self.positions += self.velocities
            self.positions = np.clip(self.positions, self.lb, self.ub)

        return self.gbest, self.gbest_val

# === Run experiments ===
if __name__ == "__main__":
    # Choisir une fonction de test
    func = rastrigin

    gsa = GSA(func, num_agents=30, dim=10, max_iter=100)
    best_sol_gsa, best_fit_gsa = gsa.run()

    pso = PSO(func, num_particles=30, dim=10, max_iter=100)
    best_sol_pso, best_fit_pso = pso.run()

    print("GSA best fitness:", best_fit_gsa)
    print("PSO best fitness:", best_fit_pso)

    # Graphe de convergence
    plt.plot(gsa.history, label="GSA")
    plt.plot(pso.history, label="PSO")
    plt.xlabel("Iteration")
    plt.ylabel("Best fitness")
    plt.title("Convergence comparison on Rastrigin function")
    plt.legend()
    plt.show()

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm

# =========================
# Benchmark functions (2D)
# =========================
def sphere(x):
    # Global min at (0,0) with f=0
    return np.sum(x**2)

def rastrigin(x):
    # Typical bounds: [-5.12, 5.12]; many local minima; global min at (0,0)
    A = 10
    return A*len(x) + np.sum(x**2 - A*np.cos(2*np.pi*x))

# =========================
# Utility helpers
# =========================
def scale_to_bounds(x, lb, ub):
    return np.clip(x, lb, ub)

def gravitational_constant(t, T, G0=100.0, alpha=20.0):
    # Exponential decay of G
    return G0 * np.exp(-alpha * (t / T))

# =========================
# GSA implementation
# =========================
class GSA:
    def __init__(self, func, num_agents=40, dim=2, max_iter=150, lb=-5.0, ub=5.0,
                 use_kbest=True, kbest_schedule=(1.0, 0.1), seed=None):
        """
        func: callable, objective function R^dim -> R
        num_agents: number of agents (masses)
        dim: search space dimension (2 recommended for visualization)
        max_iter: number of iterations
        lb, ub: bounds (scalar or array-like of size dim)
        use_kbest: enable k-best strategy (attraction from the best subset)
        kbest_schedule: (start_ratio, end_ratio) fraction of agents considered as "best" from start to end
        seed: random seed for reproducibility
        """
        self.func = func
        self.num_agents = num_agents
        self.dim = dim
        self.max_iter = max_iter
        self.lb = np.full(dim, lb) if np.isscalar(lb) else np.array(lb)
        self.ub = np.full(dim, ub) if np.isscalar(ub) else np.array(ub)
        self.use_kbest = use_kbest
        self.kstart, self.kend = kbest_schedule
        self.rng = np.random.default_rng(seed)

        # Initialize population
        self.positions = self.rng.uniform(self.lb, self.ub, (num_agents, dim))
        self.velocities = np.zeros((num_agents, dim))
        self.fitness = np.array([self.func(p) for p in self.positions])

        # Best tracking
        self.best_idx = int(np.argmin(self.fitness))
        self.best_pos = self.positions[self.best_idx].copy()
        self.best_fit = self.fitness[self.best_idx]

        # History
        self.history_best = []
        self.history_positions = []  # store positions over time (for trajectory plots)
        self.history_masses = []

    def _compute_masses(self, fitness):
        # Transform fitness to masses (minimization)
        # Normalize to avoid division by zero; better -> heavier mass
        worst, best = np.max(fitness), np.min(fitness)
        if np.isclose(worst, best):
            masses = np.ones_like(fitness) / len(fitness)
        else:
            # Shift/scale so smaller fitness => larger mass
            # Map fitness to [0,1], then invert
            norm = (fitness - best) / (worst - best + 1e-12)
            inv = 1.0 - norm
            masses = inv / (np.sum(inv) + 1e-12)
        return masses

    def _kbest_indices(self, t):
        if not self.use_kbest:
            return np.arange(self.num_agents)
        # Linearly reduce number of "best" attractors over time
        ratio = self.kstart + (self.kend - self.kstart) * (t / (self.max_iter - 1))
        k = max(1, int(np.round(ratio * self.num_agents)))
        # Get indices sorted by fitness ascending
        idx_sorted = np.argsort(self.fitness)
        return idx_sorted[:k]

    def step(self, t):
        # Update best
        self.best_idx = int(np.argmin(self.fitness))
        if self.fitness[self.best_idx] < self.best_fit:
            self.best_fit = self.fitness[self.best_idx]
            self.best_pos = self.positions[self.best_idx].copy()

        self.history_best.append(self.best_fit)
        masses = self._compute_masses(self.fitness)
        self.history_masses.append(masses.copy())
        self.history_positions.append(self.positions.copy())

        # Gravitational constant
        G = gravitational_constant(t, self.max_iter)

        # K-best attractors
        k_idx = self._kbest_indices(t)

        # Compute forces
        forces = np.zeros_like(self.positions)
        for i in range(self.num_agents):
            # Attraction only from k-best to i
            for j in k_idx:
                if i == j:
                    continue
                rij = self.positions[j] - self.positions[i]
                dist = np.linalg.norm(rij) + 1e-12
                # Stochastic coefficient to enhance exploration
                rand_ij = self.rng.random(self.dim)
                # Force magnitude: G * (Mi * Mj) / dist
                fij = (G * masses[i] * masses[j] / dist) * rij
                forces[i] += rand_ij * fij

        # Accelerations
        accelerations = forces / (masses[:, None] + 1e-12)

        # Velocity and position update
        rand_i = self.rng.random((self.num_agents, self.dim))
        self.velocities = rand_i * self.velocities + accelerations
        self.positions += self.velocities

        # Apply bounds
        self.positions = scale_to_bounds(self.positions, self.lb, self.ub)

        # Evaluate fitness
        self.fitness = np.array([self.func(p) for p in self.positions])

    def run(self, verbose=False):
        for t in range(self.max_iter):
            self.step(t)
            if verbose:
                print(f"Iter {t+1:3d} | Best fitness: {self.best_fit:.6f}")
        return self.best_pos.copy(), float(self.best_fit)

# =========================
# Visualization
# =========================
def plot_convergence(history_best, title="Convergence (Best fitness)"):
    plt.figure(figsize=(7,4))
    plt.plot(history_best, color="#0a84ff", lw=2)
    plt.xlabel("Iteration")
    plt.ylabel("Best fitness")
    plt.title(title)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

def plot_agents_2d(positions, masses=None, lb=-5, ub=5, title="Agents in 2D search space"):
    plt.figure(figsize=(5,5))
    if masses is None:
        sizes = 50
        colors = "#0a84ff"
        plt.scatter(positions[:,0], positions[:,1], s=sizes, c=colors, alpha=0.8, edgecolor="white", linewidths=0.5)
    else:
        # Scale sizes by mass for visibility
        sizes = 200 * (masses - np.min(masses)) / (np.max(masses) - np.min(masses) + 1e-12) + 40
        plt.scatter(positions[:,0], positions[:,1], s=sizes, c=masses, cmap="viridis", alpha=0.9, edgecolor="white", linewidths=0.5)
        cbar = plt.colorbar()
        cbar.set_label("Mass (normalized)")
    plt.xlim(lb, ub)
    plt.ylim(lb, ub)
    plt.axhline(0, color="gray", lw=0.6, alpha=0.5)
    plt.axvline(0, color="gray", lw=0.6, alpha=0.5)
    plt.title(title)
    plt.grid(True, alpha=0.25)
    plt.tight_layout()
    plt.show()

def plot_trajectories(history_positions, history_masses=None, lb=-5, ub=5, n_paths=10):
    # Plot trajectories of a subset of agents to avoid clutter
    steps = len(history_positions)
    N = history_positions[0].shape[0]
    idx = np.linspace(0, N-1, num=min(n_paths, N), dtype=int)

    plt.figure(figsize=(6,6))
    for i in idx:
        traj = np.array([history_positions[t][i] for t in range(steps)])
        plt.plot(traj[:,0], traj[:,1], lw=1.5, alpha=0.9)
        plt.scatter(traj[0,0], traj[0,1], c="red", s=30, zorder=3)   # start
        plt.scatter(traj[-1,0], traj[-1,1], c="green", s=40, zorder=3) # end
    plt.xlim(lb, ub)
    plt.ylim(lb, ub)
    plt.title("Agent trajectories over iterations")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

def plot_landscape_2d(func, lb=-5, ub=5, grid=200, title="Objective landscape"):
    # Heatmap of function landscape (for dim=2 functions only)
    xs = np.linspace(lb, ub, grid)
    ys = np.linspace(lb, ub, grid)
    X, Y = np.meshgrid(xs, ys)
    Z = np.zeros_like(X)
    for i in range(grid):
        for j in range(grid):
            Z[i,j] = func(np.array([X[i,j], Y[i,j]]))

    plt.figure(figsize=(6,5))
    im = plt.imshow(Z, extent=[lb, ub, lb, ub], origin="lower", cmap=cm.coolwarm, aspect="equal")
    plt.colorbar(im, label="f(x)")
    plt.title(title)
    plt.xlabel("x1")
    plt.ylabel("x2")
    plt.tight_layout()
    plt.show()

# =========================
# Demo run
# =========================
if __name__ == "__main__":
    # Choose function (dim must be 2 for landscape/agent plots)
    func = rastrigin   # try sphere or rastrigin
    dim = 2
    lb, ub = -5.12, 5.12

    gsa = GSA(
        func=func,
        num_agents=50,
        dim=dim,
        max_iter=150,
        lb=lb,
        ub=ub,
        use_kbest=True,
        kbest_schedule=(1.0, 0.2),  # from all agents attracting to only top 20% by end
        seed=42
    )

    # Run optimization
    best_pos, best_fit = gsa.run(verbose=True)
    print("\nBest position:", best_pos)
    print("Best fitness:", best_fit)

    # Plots
    plot_convergence(gsa.history_best, title="GSA convergence on Rastrigin (2D)")
    plot_landscape_2d(func, lb=lb, ub=ub, grid=200, title="Rastrigin landscape (2D)")
    # Initial and final agent distributions
    plot_agents_2d(gsa.history_positions[0], gsa.history_masses[0], lb=lb, ub=ub, title="Initial agents and masses")
    plot_agents_2d(gsa.history_positions[-1], gsa.history_masses[-1], lb=lb, ub=ub, title="Final agents and masses")
    # Trajectories
    plot_trajectories(gsa.history_positions, gsa.history_masses, lb=lb, ub=ub, n_paths=12)